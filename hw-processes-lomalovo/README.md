
## Домашнее задание 2

Осваиваемся в xv6 изнутри, реализуем свои системные вызовы, разбираемся с представлением процессов.

## Общие моменты

Надейся на лучшее, готовься к худшему. В том смысле, что не надо прятать и игнорировать возможные ошибки.
Если не придумывается разумная обработка ошибочной ситуации, хотя бы надо вернуть соответствующий код возврата.

Важна правильная реакция на ошибки. Паника в ядре и exit в приложении только в случае чего-то действительно непоправимого и неизолируемого. 

Хорошо тестируйте. Не только на одном-двух процессах в хорошем сценарии. Много процессов. Ответ, не влезающий в буфер. Плохой pid.

Добавление своих тестов к решению не является обязательным, но приветствуется.

Не закладывайтесь жестко на существующую конфигурацию xv6. Например, на количество одновременно работающих
процессов. Исходите из того, что такого рода параметры могут быть изменены и ваш код должен к этому адаптироваться.

Параметры хорошо бы проверять на разумность. И возврашать ошибки, если не прошли проверки.

Подумайте, в каких случаях нужны локи и какие именно. Если захватываете лок, позаботьтесь о его освобождении независимо
от того, по какому пути вы покинете данный участок кода.

Если что-то непонятно, спрашивайте в чате.



### Полезная информация

Документация по xv6: https://pdos.csail.mit.edu/6.828/2023/xv6/book-riscv-rev3.pdf

Кратко самое полезное про GDB: https://cs.brown.edu/courses/cs033/docs/guides/gdb.pdf

Полный GDB User Guide: https://sourceware.org/gdb/current/onlinedocs/gdb.html/



### Задание 1

Стоимость - 1 балл

Реализуйте системный вызов

```
int ps_list(int limit, int* pids)
```

Параметры:

pids - выделенная память под pid доступных процессов

limit - размер выделенной памяти

Возвращаемое значение:

Отрицательное значение, если случилась ошибка.

Иначе - количество процессов в системе на момент вызова

В рамках этого задания pids не трогаем

В программе ps реализуйте такое поведение:

```
ps count
```

печатает количество процессов

Подсказки:

* данные о процессах находятся в proc.c, proc.h

* можно посмотреть на то, как работает fork, как он изменяет эти данные


### Задание 2

Стоимость - 2 балла

Дополните реализацию системного вызова ```ps_list```.

Если количество обнаруженных процессов не превосходит limit, то заполните соотвествующие позиции в ```pids```
значениями id процессов.

Если превосходит - заполните ```limit``` позиций. Ожидается, что приложение сопоставит ```limit``` с возвращенным значением.
И если ему нужны все идентификаторы, то повторит вызов с увеличенным массивом.

В программе ps реализуйте такое поведение:

```
ps pids
```

печатает список id процессов

Подсказка:

* пример заполнения массива в пользовательском адресном пространстве можно увидеть в реализации ```read```

####  Важный момент

На первый взгляд это чисто техническое задание на два последовательных системных вызова.

Но все не так просто. Между вызовом, определившим количество процессов и вызовом, желающим собрать их `pid`-ы, пройдет какое-то
время. За это время могут быть созданы новые процессы. А какие-то, возможно, завершат работу.

Точнее даже будет так. За время между двумя системными вызовами может произойти переключение контекста, и к тому моменту, когда
процессор вернут нашему процессу может пройзойти произвольное число fork/exit. 

В некотором смысле мы всегда будем видеть неточную картину. Потому что в тот момент, когда мы читаем вывод программы на
терминале, состояние процессов уже могло поменяться.

Но это не значит, что мы теперь готовы получить любые приблизительные данные.

Попробуем сформулировать требования к ожидаемому результату.

Представим шкалу времени жизни нашей системы. Каждому запуску процесса соответствует точка на этой шкале. И каждому завершению -
еще одна точка.

И для любой точки на этой шкале можно однозначно сказать, какие процессы были запущенными в данный момент времени.

У запуска `ps pids` тоже есть свой отрезок.

`ps pids` будет считаться работающим корректно, если те `pid`-ы, которые будут выведены, соответствуют тем процессам, которые
были запущенными в какой-то точке времени между запуском и завершением `ps pids`.

В идеале, множество выведенных `pid`-ов должно быть строго равно множеству `pid`-ов, бывших запущенными и незавершенными в какой-либо из
моментов, когда  `ps pids` был запущен и не завершен.

Например, если в момент старта `ps pids` в системе работали процессы 1, 5, 7, `ps pids` стартовал с `pid` 9, после чего 7 завершился,
а 10 стартовал и, наконец, `ps pids` завершился, то варианты корректного вывода - `1, 5, 7, 9`, `1, 5, 9` или `1, 5, 9, 10`.

В свете сказанного, получается, что данные о количестве процессов из предыдущего системного вызова могут малость устареть. И на это надо
рассчитывать. Особенно неприятна ситуация, при которой процессов стало больше.

Можно решить ее радикально, сразу передав большой массив, в который влезут все процессы. Но мы хотим, чтобы наш код не закладывался
на текущие детали работы ОС. А потенциально в ОС может быть бесконечно много процессов. Если почти все они спят - это даже не будет
большой нагрузкой.

Ну давайте все-таки сделаем одно допущение - что количество максимально работающих процессов ограничено константой. Но эта константа
может быть большой  и мы даже не хотим ее знать. Не такой большой, чтобы мы не смогли создать массив целых такой длины. 
Но достаточно большой, чтобы мы не хотели сразу же захватывать массив такой длины.

Получается, что число процессов из первого вызова мы должны использовать как оценку размера массива, но его может оказаться мало - и тогда
надо что-то делать. Ну точно не стоит запрашивать новую оценку. Надо ее как-то разумно увеличить. Но быть готовыми к тому, что и увеличенной
может не хватить. Утешает то, что все-таки это не будет бесконечным, но некий цикл возможен. Постарайтесь сделать так, чтобы число повторных
попыток было сублинейным относительно этого самого неведомого максимума числа процессов. Но и память с чрезмерным запасом не использовать.



### Задание 3

Стоимость - 2 балла

Реализуйте системный вызов

```
int ps_info(int pid, process_info* psinfo)
```

Параметры:

pid - идентификатор процесса

pinfo - выделенная память под структуру типа process_info

Возвращаемое значение:

Отрицательное значение, если случилась ошибка.

Иначе - 0

Если ошибки нет, то заполняется структура psinfo

Структуру определяете вы.

В ней должны быть следующие данные о процессе:

* состояние

* id родителя, 0 для init

* размер памяти

* количество открытых файлов

* имя процесса

В программе ps реализуйте такое поведение:

```
ps list
```

печатает данные о процессах.

Ожидается, что она вызовет сначала ```ps_list```, а потом ```ps_info``` для каждого процесса.

Если после ps_list кто-то запустится, не беда. Просто не попадет в список.

Если кто-то перестанет работать, это надо учесть в обработке результатов ```ps_info```

#### Замечание

Если аккуратно сделать предыдущее задание и учесть ошибку в ```ps_info```, все равно возможны некоторые гонки.

Например, мы могли зафиксировать момент, когда процессы A и B работали и ```ps_list``` вернул их идентификаторы.

Потом по порядку: мы вызвали ```ps_info``` для A,  завершился A, завершился B, мы вызвали ```ps_info``` для B.

И мы выведем данные для A, но не выведем для B - хотя не было такого момента, когда бы A работал, а B - нет.

Будем считать такой вариант допустимым.

Еще могут быть сценарии нарушения корректности снимка состояния, если система может переиспользовать `pid`-ы завершенных
процессов. Например, если между  ```ps_list``` и ```ps_info```  процесс завершился, но успел стартовать новый с тем же
`pid`-ом, то мы его увидим. Но мы не увидим того, кто стартовал после ```ps_list``` с `pid`-ом не из возвращенного списка,
даже если он стартовал до того, который переиспользовал освободившийся `pid`. 

С этим тоже не боремся. 

Ну и принцип "снимка" из прошлого задания мы здесь не переносим на детали состояния процессов. Для этого надо было бы
```ps_info``` вызывать с массивом структур - как ```ps_list```.


### Задание 4

Стоимость - 3 балла

Хотим узнать детали о времени работы процесса:

- сколько тиков прошло с момента старта

- сколько тиков процесс реально работал

- сколько тиков процесс реально работал в пользовательском режиме

- сколько тиков процесс реально работал в системном режиме

- сколько тиков процесс готов был работать, но его не пускали на исполнение

- сколько раз переключался контекст на данный процесс

Такой информации сейчас нет. Но тики считаются. Можно опереться на реализацию системного вызова
`uptime`, чтобы понять, как работать с тиками.

Скорее всего надо будет как-то расширить состояния процесса.

Переполнием счетчика тиков можно пренебречь.

По умолчанию в xv6 тики довольно редкие, что может смазывать результаты. В таком случае можно сделать их почаще.
Или в тестовом коде что-то подольше считать, увеличить число активных процессов и т.п..

Обновите структуру `process_info` и поведение `ps`.

### Задание 5

Стоимость - 2 балла

Хотим узнать

- сколько байтов процесс записал в любые файловые дескрипторы

- сколько байтов процесс прочитал из любых файловых дескрипторов

- сколько сколько страниц, предназначенных для кучи, на данный момент передано процессу 

Обновите структуру `process_info` и поведение `ps`.

