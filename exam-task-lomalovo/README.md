

## Где и на чем собирать

С докером вышла неприятность.

Давайте так: где собираете xv6 - там и пишите задание.

Если в Windows - у вас скорее всего WSL с Ubuntu и это вполне подойдет.

Если какой-то Linux над маком - тоже все хорошо.

Если вдруг у вас чистый Mac - используйте POSIX/SysV API. 
Если вам было невмоготу без чего-то сугубо Linux-ного - сообщите об этом 
в устной части. Я учту. 

## Задание

Напишите приложение, которое суммирует числа, хранящиеся в файлах.

Приложение получает два параметра командной строки:

- имя файла

- степень параллелизма

Гарантируется, что 

- при любом вызове приложения у него будут два параметра

- первый - имя файла, который существует, на него есть права, его никто
не удалит по ходу и т.п., не будет никаких ошибок чтения

- второй - натуральное число от 1 до 20

Содержимое файла - имена обрабатываемых файлов с данными. По имени на строку.
Имена не повторяются. Имен может быть от 1 до 10000.
 
Также гарантируется, что каждый перечисленный файл существует,
на него есть права и т.п.

И если имя файла задано не абсолютным путем, то оно задается от текущего пути приложения. То есть имена можно как есть пихать в open.

И имена не длиннее, чем 200 символов.

В этих файлах хранятся числа в десятичном представлении, влезающие в int.

Эти файлы могут быть любой длины и они тоже все всегда прочитаются.

Пример данных находится в каталоге example.

Надо просуммировать все числа во всех файлах, пренебрегая переполнением.

### Базовая часть

Выполнение этой части обеспечивает 80 процентов от максимальной оценки.

В этой части мы ориентируемся на ситуацию "файлов значительно больше, чем 
степень параллелизма, их размеры примерно равны и они не микроскопических
размеров (мегабайт и больше)".

Надо написать приложение на С, которое запускается одно из командной строки,
весь параллелизм организует самостостоятельно и в итоге печатает сумму всех чисел во всех файлах.

Если помимо "читателей" приложению нужен какой-то служебный координирующий процесс, на него степень
параллелизма не "тратится". Например, при степени параллелизма 3 три процесса читают файлы, а еще один
может собирать посчитанные суммы для файлов

### Продвинутая часть

Выполнение этой части обеспечивает 20 процентов от максимальной оценки, если есть базовая.

Можно сразу сделать продвинутую без базовой и при успехе она даст 100 процентов
от максимальной оценки.

Здесь хотелось бы адаптироваться к ситуации файлов разношерстных размеров. Например, 1000 файлов по мегабайту и парочка по гигабайту.

Но мы даже здесь НЕ заботимся об эффективности в ситуации типа "один гигантский файл", не пытаемся читать его параллельно и т.п.

## Что можно, что нельзя

Нельзя использовать прикладные нитевые API (pthreads и т.п.). Только clone.
Ну или fork.

