
## Домашнее задание 1

Тема - знакомство с xv6 с точки зрения програмного API.

## Общие моменты

В ситуациях, описанных как ошибки, нужно

- завершить программу с ненулевым код завершения

- напечатать адекватную диагностику на ошибочный выход

Надо опираться на описания системных вызовов и учитывать все возможные
ситуации, которые с точки зрения их описаний являются корректными.

Не надо изобретать велосипед в том смысле, что если что-то полезное уже определено в
каталоге user, надо этим пользоваться.

В момент сдачи убедитесь, что все закомитили и запушили.
А также в том, что все собирается, запускается и никакие тестовые программы
не стали падать.

### Полезная информация

Документация по xv6: https://pdos.csail.mit.edu/6.828/2023/xv6/book-riscv-rev3.pdf

Особенно полезна глава 1.

Кратко самое полезное про GDB: https://cs.brown.edu/courses/cs033/docs/guides/gdb.pdf

Полный GDB User Guide: https://sourceware.org/gdb/current/onlinedocs/gdb.html/

### Задание 1

Стоимость - 1 балл

На семинаре мы занимались утилитой head. 

Разовьем успех. Реализуем следующие возможности:

- дадим возможность указывать количество выводимых данных и единицу их измерения

- дадим возможность получать данные со стандартного входа

Количество данных и единица измерения задается с помощью опций командной строки `--bytes` или
`--lines`.

Если не указана ни одна из этих опций - выводим первые 10 строчек.

Если указана любая из них, то за ней непосредственно должен следовать знак `=`, а за ним -
положительное целое число.

Например, `--lines=5` или `--bytes=120`.

Если указаны обе опции одновременно, то это ошибка.

Если нарушены правила, описывающие их структуру, то это ошибка.

В идеале, хорошо бы еще учесть случай, когда число указано, но оно не влезает в `int` или даже в
`long long`. Но здесь упростим. Считаем, что гарантируется, что число не превосходит 32767.

Что касается источника данных - будем считать, что если файл указан, но берем первые строки/байты
из файла, а если не указан - то со стандартного входа.

Файл может указываться только один. Если больше - это ошибка. Или может не указываться.

Если файл указан, то опции `--lines`/`--bytes` должны идти до файла.
Если они идут после файла, то это ошибка.

Если указанный файл не существует, то это ошибка.

Если командная строка корректна и указанный входной файл существует, то результирующие данные
пишутся на стандартный выход (в отличие от диагностики, которая пишется на ошибочный выход).


## Задание 2

Стоимость - 2 балла.

Реализуем утилиту `tail`.

По поведению - аналогично `head`, только выводим данные в конце файла.

Все правила обработки командной строки - как для `head`.

Есть одно важное отличие. Как минимум, в случае стандартного входа мы не знаем,
сколько строк/байт у нас на входе. И мы хотим масштабироваться на длину входа.
При этом мы полагаем, что длина интересующего нас "хвоста" разумна в том смысле,
что его можно считать влезающим в память. В отличие от всего входа. Но память может быть
тоже немаленькой.

Другими словами, мы хотим эффективно обработать сценарий "100 последних строчек
входа, длину которого мы по ходу чтения не знаем и которая может быть 50Gb" и сценарий 
"последние 100Mb". А сценарий "последние 20 GB" мы не рассматриваем.

От линии по длине входа нам никуда не деться. Но НЕ хотелось бы получить что-то дороже линии
от длины хвоста. И ничего вспмогательного на диск не писать.

(Тут должно хватить знаний базового курса по алгоритмам и структурам данных)


## Задание 3

Стоимость - 1 балл

На семинаре мы использовали утилиту `less`. Она позволяет просматривать в терминале текстовый файл.
Но она требует определенных возможностей терминала и кода для их использования.

В ранних версиях Unix-систем была популярна более простая по интерфейсу утилита `more`. Она позволяла
двигаться по длинному тексту в одном направлении. Выводила все больше и больше текста по запросу
пользователя. Поэтому и называлась `more`. А `less` - игра слов с отсылкой на `more`.

Я ее упоминаю в прошедшем времени, потому что она была популярна давно, но она никуда не делась и в
Ubuntu она есть и сейчас, хотя и не так популярна.

А в этом задании мы ее реализуем для xv6. 

Хотим, чтобы она принимала тот же шаблон параметров, что и `head`.

Поведение ожидается следующее:

- выводим порцию данных от начала как в случае `head`

- если данные не кончились, то пишем приглашение 'Press Enter to continue'

- по нажатии Enter выводим следующую порцию

- и так далее, пока данные не закончатся

`xv6` не предоставляет простого API для непосредственного реагирования на события с клавиатуры.
Поэтому будет нормальным реализовать взаимодействие через `read`.


## Задание 4 
 
Стоимость - 2 балла

Упрощенный вариант утилиты cp.

Хотим копировать файлы.

Никаких стандартных вводов-выводов, только командная строка.

Ожидаем ровно два аргумента: имя копируемого файла и имя того места, куда копируем.

Если первый аргумент не является именем существующего элемента файловой системы, то это ошибка.

Если первый аргумент - каталог, то это ошибка.

Если первый аргумент - ссылка, ссылающаяся на каталог, то это ошибка.

Если первый или второй аргумент - устройство или ссылка на устройство, то это ошибка.

Если дошли досюда, то первый аргумент - существующий файл или ссылка на таковой.

А вторым аргументом может быть существующий файл, существующий каталог или несуществующий объект.

Если это существующий файл, то мы почти готовы к копированию. Надо только случай со ссылками учесть.
Если два файла представляют собой ссылку на один `inode`, то мы ничего не копируем, но завершаемся с кодом возврата
0. То есть считаем это успехом.

Если это несуществующий объект, но проверяем, а существует ли путь до него.
Если не существует, то это ошибка.

Например, если дошли досюда с командой `cp abc def/qwerty', то проверяем, а существует ли каталог 
`def`.

Если путь существует, то приступаем к копированию.

Остался вариант, когда первый аргумент - существующий файл (или ссылка), а второй - существующий каталог
(или ссылка).

В этом случае мы берем непосредственно имя файла из первого аргумента (последний элемент пути, если имя было
задано с путем). И мысленно подставляем его в конец второго аргумента. Если второй аргумент заканчивается на
`/`, то просто подставляем, а если нет - добавляем `/`.

Например для команды `cp /abc/def /q/w/` получим `cp /abc/def /q/w/def`, а для команды
`cp /abc/def /q/w` - тоже `cp /abc/def /q/w/def`.

И в мы попробуем исполнить такую модифицированную команду согласно уже имеющимся правилам за одним
исключением - если окажется, что такой модифицированный второй аргумент стал указывать на каталог,
то мы не пойдем рекурсивно повторять ту же схему, а сочтем это ошибкой.

Итак, к этому моменту мы либо знаем, что куда копировать, либо уже сломались.

А дальше надо учесть, что могут быть ошибки при открытии, создании файлов, а также при чтении/записи - 
как минимум, может кончиться место на диске.

В таких ситуациях надо порождать адекватную диагностику. 

А помимо ошибок бывают законные вариации в поведении. Надо внимательно разобраться в интерфейсе используемых
 системных вызовов, чтобы все учесть.


## Задание 5

Стоимость: 2 балла

Утилита du.

Подсчет места, занимаемого файлами данного подкаталога.

Один параметр командной строки - имя каталога.

Если каталог не существует, то это ошибка.

Надо пройти по дереву подкаталогов и просуммировать занимаемое место.

Место, занимаемое отдельным файлом, определяем по метаданным файла, не чтением данных.

Изюминка тут в ссылках.

Если два и более имен ссылаются на один файл, то его размер считаем один раз.

(Линки на каталоги xv6 не поддерживает, что несколько упрощает дело).


## Задание 6

Стоимость: 2 балла

Командная оболочка в xv6 предельно проста.

Но кое-что в ней поддерживается из того, что свойственно Unix-shell-ам.

Например, конвейерное исполнение нескольких процессов с перенаправлением стандартного ввода-вывода.

Но не поддерживается перенапраление ошибочного вывода.

В этом задании необходимо модифицировать `user/sh.c`, чтобы поддержать следующие конструкции:

- `2>err.txt` - перенаправление ошибочного вывода в файл 

- `2>>err.txt` - перенаправление ошибочного вывода с добавлением

- `2>&1` - ошибочный вывод идет на стандартный 

Если в одной команде сочетается перенаправление `2>&1` и перенаправление стандартного вывода вроде `>filename`,
то они выполняются независимо друг от друга. Т.е. то, что в коде приложения направлялось в `stderr`, идет в `stdout`,
а то, что направлялось в `stdout`  - идет в файл `filename`.

Если же после команды идет продолжение конвейера, то следующему процессу на стандартный вход подается все, что было перенапралено
на стандартный выход.

Например `cat 2>&1 | wc` должно передать на вход wc содержимое файла, если он существует и может быть прочитан и любые
возможные сообщения об ошибках от `cat` (например, сообщение о том, что такого файла нет).

